name: Database Backup via Tailscale

on:
  schedule:
    - cron: '0 2 * * *'  # Daily at 2 AM UTC
  workflow_dispatch:
    inputs:
      backup_retention_days:
        description: 'Number of days to retain backup'
        required: false
        default: '7'
        type: string

env:
  BACKUP_DIR: /tmp/backups
  TIMESTAMP: $(date +%Y%m%d_%H%M%S)

jobs:
  backup:
    runs-on: ubuntu-latest
    environment: production
    
    steps:
      - name: Setup Tailscale
        uses: ./.github/actions/setup-tailscale
        with:
          authkey: ${{ secrets.TAILSCALE_AUTHKEY }}
          timeout: 60

      - name: Install Database Tools
        run: |
          sudo apt-get update
          sudo apt-get install -y postgresql-client mysql-client

      - name: Create Backup Directory
        run: |
          mkdir -p $BACKUP_DIR
          chmod 700 $BACKUP_DIR

      - name: Backup PostgreSQL Database
        if: vars.POSTGRES_HOST != ''
        env:
          PGPASSWORD: ${{ secrets.POSTGRES_PASSWORD }}
          PGHOST: ${{ vars.POSTGRES_HOST || '100.64.0.6' }}
          PGUSER: ${{ vars.POSTGRES_USER || 'postgres' }}
          PGDATABASE: ${{ vars.POSTGRES_DATABASE || 'myapp' }}
        run: |
          echo "Creating PostgreSQL backup..."
          
          # Create database dump
          pg_dump -h $PGHOST -U $PGUSER -d $PGDATABASE \
            --verbose --no-password \
            --format=custom \
            --file=$BACKUP_DIR/postgres_${TIMESTAMP}.dump
          
          # Verify backup was created
          if [ -f "$BACKUP_DIR/postgres_${TIMESTAMP}.dump" ]; then
            SIZE=$(du -h "$BACKUP_DIR/postgres_${TIMESTAMP}.dump" | cut -f1)
            echo "✅ PostgreSQL backup created: $SIZE"
          else
            echo "❌ PostgreSQL backup failed"
            exit 1
          fi

      - name: Backup MySQL Database
        if: vars.MYSQL_HOST != ''
        env:
          MYSQL_PWD: ${{ secrets.MYSQL_PASSWORD }}
        run: |
          echo "Creating MySQL backup..."
          
          # Create database dump
          mysqldump -h ${{ vars.MYSQL_HOST || '100.64.0.6' }} \
            -u ${{ vars.MYSQL_USER || 'root' }} \
            --single-transaction \
            --routines \
            --triggers \
            ${{ vars.MYSQL_DATABASE || 'myapp' }} > $BACKUP_DIR/mysql_${TIMESTAMP}.sql
          
          # Compress the backup
          gzip $BACKUP_DIR/mysql_${TIMESTAMP}.sql
          
          # Verify backup was created
          if [ -f "$BACKUP_DIR/mysql_${TIMESTAMP}.sql.gz" ]; then
            SIZE=$(du -h "$BACKUP_DIR/mysql_${TIMESTAMP}.sql.gz" | cut -f1)
            echo "✅ MySQL backup created: $SIZE"
          else
            echo "❌ MySQL backup failed"
            exit 1
          fi

      - name: Test Backup Integrity
        run: |
          echo "Testing backup integrity..."
          
          # Test PostgreSQL backup if it exists
          if [ -f "$BACKUP_DIR/postgres_${TIMESTAMP}.dump" ]; then
            echo "Testing PostgreSQL backup..."
            pg_restore --list $BACKUP_DIR/postgres_${TIMESTAMP}.dump > /dev/null
            echo "✅ PostgreSQL backup integrity check passed"
          fi
          
          # Test MySQL backup if it exists
          if [ -f "$BACKUP_DIR/mysql_${TIMESTAMP}.sql.gz" ]; then
            echo "Testing MySQL backup..."
            gunzip -t $BACKUP_DIR/mysql_${TIMESTAMP}.sql.gz
            echo "✅ MySQL backup integrity check passed"
          fi

      - name: Upload to Storage
        run: |
          echo "Uploading backups to remote storage..."
          
          # Example: Upload to AWS S3 (uncomment and configure)
          # aws configure set aws_access_key_id ${{ secrets.AWS_ACCESS_KEY_ID }}
          # aws configure set aws_secret_access_key ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          # aws configure set default.region ${{ vars.AWS_REGION || 'us-east-1' }}
          # 
          # for backup_file in $BACKUP_DIR/*; do
          #   if [ -f "$backup_file" ]; then
          #     aws s3 cp "$backup_file" s3://${{ vars.BACKUP_BUCKET }}/$(date +%Y/%m/%d)/
          #   fi
          # done
          
          # Example: Upload to MinIO/S3-compatible storage
          # mc alias set backup ${{ vars.MINIO_ENDPOINT }} ${{ secrets.MINIO_ACCESS_KEY }} ${{ secrets.MINIO_SECRET_KEY }}
          # mc cp $BACKUP_DIR/* backup/${{ vars.BACKUP_BUCKET }}/$(date +%Y/%m/%d)/
          
          # For demonstration, just show what would be uploaded
          echo "Files to upload:"
          ls -lah $BACKUP_DIR/

      - name: Cleanup Old Backups
        run: |
          echo "Cleaning up old backups..."
          
          # Example cleanup for S3 (uncomment and configure)
          # RETENTION_DAYS="${{ github.event.inputs.backup_retention_days || '7' }}"
          # CUTOFF_DATE=$(date -d "$RETENTION_DAYS days ago" +%Y-%m-%d)
          # aws s3 rm s3://${{ vars.BACKUP_BUCKET }}/ --recursive \
          #   --exclude "*" --include "*" \
          #   --query "Contents[?LastModified<='$CUTOFF_DATE'].Key" \
          #   --output text
          
          echo "Cleanup configuration: retain ${{ github.event.inputs.backup_retention_days || '7' }} days"

      - name: Generate Backup Report
        run: |
          cat >> $GITHUB_STEP_SUMMARY << EOF
          # Database Backup Report
          
          **Backup Date:** $(date -u)
          **Retention Policy:** ${{ github.event.inputs.backup_retention_days || '7' }} days
          
          ## Backup Details
          EOF
          
          # Add backup file details to report
          for backup_file in $BACKUP_DIR/*; do
            if [ -f "$backup_file" ]; then
              FILENAME=$(basename "$backup_file")
              SIZE=$(du -h "$backup_file" | cut -f1)
              echo "- **$FILENAME:** $SIZE" >> $GITHUB_STEP_SUMMARY
            fi
          done
          
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "## Status" >> $GITHUB_STEP_SUMMARY
          echo "✅ Backup completed successfully" >> $GITHUB_STEP_SUMMARY

      - name: Cleanup
        if: always()
        run: |
          # Securely remove local backup files
          rm -rf $BACKUP_DIR
          
          # Disconnect from Tailscale
          sudo tailscale logout || true
          sudo systemctl stop tailscaled || true