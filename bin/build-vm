#!/usr/bin/env python3
"""
build-vm - Fast VM testing for NixOS configurations

This script uses nixos-rebuild build-vm for rapid iteration on configurations
without the overhead of full deployment (no disko/encryption/secure boot).
"""

import os
import sys
import subprocess
import time
import shutil
import signal
import argparse
import glob

# --- Configuration for VM access ---
VM_USER = "testuser"      # Default user for SSH. Adjust if your VM uses a different user.
VM_PASSWORD = "testpass"  # Default password for desktop login info.
SSH_PORT = 2222           # Default SSH port for VM.

# ANSI colors
RED = '\033[0;31m'
GREEN = '\033[0;32m'
YELLOW = '\033[1;33m'
BLUE = '\033[0;34m'
CYAN = '\033[0;36m'
NC = '\033[0m'  # No Color

def print_step(msg):
    print(f"{BLUE}==>{NC} {msg}")

def print_success(msg):
    print(f"{GREEN}✓{NC} {msg}")

def print_error(msg):
    print(f"{RED}✗{NC} {msg}")

def print_warning(msg):
    print(f"{YELLOW}⚠{NC} {msg}")

def print_info(msg):
    print(f"{CYAN}ℹ{NC} {msg}")

def run_command(cmd, check=True, shell=False, env=None):
    """Run a shell command."""
    try:
        subprocess.run(cmd, check=check, shell=shell, env=env)
        return True
    except subprocess.CalledProcessError:
        return False

def check_port_in_use(port):
    """Check if a port is in use using ss."""
    try:
        # Check TCP listening ports
        result = subprocess.run(
            ["ss", "-tln"], 
            capture_output=True, 
            text=True, 
            check=False
        )
        return f":{port} " in result.stdout
    except FileNotFoundError:
        # Fallback if ss is missing, though unlikely on Linux
        return False

def kill_process_on_port(port):
    """Find and kill process listening on a specific port."""
    try:
        # Get PID using ss
        cmd = f"ss -tlnp | grep ':{port} ' | grep -o 'pid=[0-9]*' | head -1 | cut -d= -f2"
        result = subprocess.run(
            cmd,
            shell=True,
            capture_output=True,
            text=True
        )
        pid = result.stdout.strip()
        
        if pid:
            print_info(f"Killing process {pid} using port {port}...")
            os.kill(int(pid), signal.SIGTERM)
            time.sleep(2)
            try:
                os.kill(int(pid), 0) # Check if still alive
                os.kill(int(pid), signal.SIGKILL) # Force kill if needed
            except OSError:
                pass # Process is gone
            return True
    except Exception as e:
        print_warning(f"Failed to kill process on port {port}: {e}")
    return False

def wait_for_ssh(port, user, host="localhost", timeout=60):
    """Wait for SSH to become available."""
    start_time = time.time()
    while time.time() - start_time < timeout:
        try:
            cmd = [
                "ssh",
                "-o", "StrictHostKeyChecking=no",
                "-o", "UserKnownHostsFile=/dev/null",
                "-o", "ConnectTimeout=1",
                "-o", "LogLevel=ERROR",
                "-p", str(port),
                f"{user}@{host}",
                "echo ready"
            ]
            subprocess.run(cmd, check=True, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
            return True
        except subprocess.CalledProcessError:
            time.sleep(1)
    return False

def main():
    parser = argparse.ArgumentParser(
        description="Build and automatically connect to VMs for fast testing of NixOS configurations.",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog=f"""
Examples:
  {sys.argv[0]} workstation               # Build and SSH into workstation
  {sys.argv[0]} test-vm                   # Build and run test-vm
  {sys.argv[0]} workstation --clean       # Clean, rebuild, and connect
  {sys.argv[0]} workstation --build-only  # Just build, don't open console
        """
    )
    
    parser.add_argument(
        "config_name", 
        nargs="?", 
        default="workstation",
        help="NixOS configuration name (default: workstation)"
    )
    parser.add_argument(
        "--build-only", 
        action="store_true", 
        help="Build VM but don't run/connect"
    )
    parser.add_argument(
        "--clean", 
        action="store_true", 
        help="Remove old VM artifacts before building"
    )

    args = parser.parse_args()
    
    config = args.config_name
    vm_hostname = config
    disk_image = f"{vm_hostname}.qcow2"
    
    # Check for config existence (basic check)
    if not os.path.exists("flake.nix"):
        print_error("flake.nix not found in current directory")
        sys.exit(1)

    # Clean if requested
    if args.clean:
        print_step("Cleaning old VM artifacts")
        if os.path.exists(disk_image):
            os.remove(disk_image)
            print_success(f"Removed {disk_image}")
        
        if os.path.islink("result"):
            os.unlink("result")
            print_success("Removed result symlink")
            
        # Also clean up PID files
        pid_files = glob.glob(f"build-vm-*.pid")
        for pf in pid_files:
            try:
                os.remove(pf)
            except OSError:
                pass

    # Build VM
    print_step(f"Building VM for configuration: {config}")
    print_info("This may take a few minutes on first build...")
    
    build_cmd = ["nixos-rebuild", "build-vm", "--flake", f".#{config}"]
    if not run_command(build_cmd):
        print_error("Failed to build VM")
        sys.exit(1)

    print_success("VM built successfully")
    
    vm_script = f"./result/bin/run-{vm_hostname}-vm"
    
    # Show build information
    print("")
    print_info(f"Configuration: {config}")
    print_info(f"VM script:     {vm_script}")
    print_info(f"Disk image:    {disk_image}")
    print("")

    if args.build_only:
        print_info("Build complete. To run manually:")
        print(f"  {vm_script}")
        sys.exit(0)

    # Determine functionality based on configuration name or simple heuristic
    # Ideally we'd know if it's a terminal or desktop config.
    # For now, we'll try to detect if it's a headless run or graphical.
    # Actually, the original script used explicit 'terminal' vs 'desktop' keywords
    # but we generalized it.
    # Let's assume if it's 'test-vm' it might be graphical, others might be SSH.
    # However, 'run-nixos-vm' usually spawns a QEMU window unless -nographic is passed.
    
    # We will replicate the logic:
    # If the user wants to "just start a desktop VM", they usually run the script.
    # The original script split 'terminal' (auto-ssh) and 'desktop' (GUI).
    # Since we don't know the intent purely from the config name, 
    # we can check if the user *requested* a specific mode, or just run the script.
    # But since we replaced the logic with just "config name", we lose the explicit mode switch.
    
    # Strategy:
    # Always run the VM script directly. QEMU will open a window if it's a graphical system.
    # If it's a server system, it might still open a window with a login prompt.
    # The 'terminal' mode in the bash script was special: it started QEMU in background
    # and SSH'd in. This is useful for dev environments.
    
    # To support the "terminal" workflow (headless + SSH), we might need a flag.
    # But for "Just start a desktop VM", executing the script is the right path.
    
    # Let's assume standard behavior is running the script (Desktop/Console mode).
    # If the user wants headless/SSH, we might add a flag later, or if the config
    # implies it.
    
    # However, the user liked the "terminal" workflow for "terminal" config.
    # Let's add a --headless-ssh flag, or check if the config name contains "terminal"
    # to maintain backward compat logic from the bash script, roughly.
    
    is_terminal_workflow = "terminal" in config
    
    if is_terminal_workflow:
        print_step("Starting terminal VM in background...")
        pid_file = f"./build-vm-{config}.pid"
        
        # Cleanup existing PID
        if os.path.exists(pid_file):
            try:
                with open(pid_file, 'r') as f:
                    old_pid = int(f.read().strip())
                try:
                    os.kill(old_pid, 0)
                    print_info(f"Stopping existing VM (PID {old_pid})...")
                    os.kill(old_pid, signal.SIGTERM)
                    time.sleep(2)
                except OSError:
                    pass
                os.remove(pid_file)
            except (ValueError, OSError):
                pass

        if check_port_in_use(SSH_PORT):
            print_warning(f"Port {SSH_PORT} is already in use")
            kill_process_on_port(SSH_PORT)

        # Start VM in background
        # We need to suppress output for background run
        with open(os.devnull, 'w') as devnull:
            env = os.environ.copy()
            # QEMU_NET_OPTS/QEMU_KERNEL_PARAMS can be used to ensure headless if needed,
            # but usually the VM config dictates it. 
            # If we want to force headless, we might need 'nographic' appended?
            # The nixos VM script usually respects QEMU_OPTS.
            env['QEMU_OPTS'] = f"{env.get('QEMU_OPTS', '')} -nographic" 
            
            proc = subprocess.Popen(
                [vm_script], 
                stdout=devnull, 
                stderr=devnull,
                env=env,
                start_new_session=True
            )
        
        with open(pid_file, 'w') as f:
            f.write(str(proc.pid))

        print_info(f"VM started (PID {proc.pid})")
        print_info("Waiting for VM to boot and SSH to be ready...")
        
        time.sleep(5) # Grace period
        
        if wait_for_ssh(SSH_PORT, VM_USER):
            print_success("VM is ready!")
            print("")
            print_info("Connecting via SSH (automatic key authentication)...")
            print_warning("VM will keep running in background after you exit SSH")
            print_info(f"To stop VM: kill {proc.pid}  or  kill $(cat {pid_file})")
            print("")
            
            # Interactive SSH session
            subprocess.run([
                "ssh", 
                "-o", "StrictHostKeyChecking=no", 
                "-o", "UserKnownHostsFile=/dev/null",
                "-o", "LogLevel=ERROR",
                "-p", str(SSH_PORT),
                f"{VM_USER}@localhost"
            ])
            
            print("")
            print_info("SSH session ended")
            print_info(f"VM is still running in background (PID {proc.pid})")
            print_info(f"To reconnect: ssh -p {SSH_PORT} {VM_USER}@localhost")
            print_info(f"To stop VM: kill {proc.pid}")
            
        else:
            print_error("SSH did not become ready in time")
            print_info(f"VM is still running in background (PID {proc.pid})")
            print_info(f"Try manually: ssh -p {SSH_PORT} {VM_USER}@localhost")
            sys.exit(1)

    else:
        # Desktop / Standard mode
        print_step("Starting VM with graphical console...")
        print_info(f"Login with: {VM_USER} / {VM_PASSWORD}")
        print_info("Press Ctrl-C or use 'poweroff' in VM to stop")
        print("")
        
        try:
            subprocess.run([vm_script])
        except KeyboardInterrupt:
            print("")
            print_info("VM stopped")

if __name__ == "__main__":
    main()