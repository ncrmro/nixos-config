#!/usr/bin/env bash

# GitHub Actions Secrets Management Script
# Generates fresh Tailscale auth keys and kubeconfig for GitHub Actions
# Creates namespace with service account for the repository

set -euo pipefail

MERCURY_HOST="root@mercury.ncrmro.com"
OCEAN_HOST="root@ocean.mercury"
HEADSCALE_USER="ncrmro"
KUBECONFIG="$HOME/.kube/config.ocean.yml"

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

log_info() {
    echo -e "${BLUE}ℹ️  $1${NC}" >&2
}

log_success() {
    echo -e "${GREEN}✅ $1${NC}" >&2
}

log_warning() {
    echo -e "${YELLOW}⚠️  $1${NC}" >&2
}

log_error() {
    echo -e "${RED}❌ $1${NC}" >&2
}

show_help() {
    cat <<EOF
GitHub Actions Secrets Management

Usage: $0 <owner/repo> [environment]

Arguments:
  owner/repo    GitHub repository (e.g., ncrmro/website)
  environment   Environment name (default: prod)

Examples:
  $0 ncrmro/website         # Creates ncrmro-website-prod namespace
  $0 ncrmro/website dev      # Creates ncrmro-website-dev namespace

This script will:
1. Create a new ephemeral reusable Tailscale auth key on Mercury
2. Create a Kubernetes namespace with repository label
3. Create a service account with access to labeled namespaces
4. Generate kubeconfig for the service account
5. Automatically set secrets in GitHub repository

Requirements:
- GitHub CLI (gh) must be installed and authenticated
- SSH access to Mercury and Ocean hosts

EOF
}

check_dependencies() {
    log_info "Checking dependencies..."
    
    # Check if GitHub CLI is installed
    if ! command -v gh >/dev/null 2>&1; then
        log_error "GitHub CLI (gh) not found. Please install it first:"
        echo "  • On NixOS: Add 'gh' to your packages" >&2
        echo "  • Or visit: https://cli.github.com/" >&2
        exit 1
    fi
    
    log_success "Dependencies verified"
}

check_github_auth() {
    log_info "Checking GitHub authentication..."
    
    # Check if user is authenticated with GitHub CLI
    if ! gh auth status >/dev/null 2>&1; then
        log_error "GitHub CLI not authenticated. Please run:"
        echo "  gh auth login" >&2
        exit 1
    fi
    
    log_success "GitHub authentication verified"
}

test_connectivity() {
    log_info "Testing connectivity to hosts..."
    
    if ! ssh -o ConnectTimeout=10 "$MERCURY_HOST" "echo 'Mercury connection test'" >/dev/null 2>&1; then
        log_error "Cannot connect to Mercury server at $MERCURY_HOST"
        exit 1
    fi
    
    # Test Kubernetes cluster connectivity using local kubeconfig
    if ! kubectl --kubeconfig="$KUBECONFIG" cluster-info >/dev/null 2>&1; then
        log_error "Cannot connect to Kubernetes cluster using $KUBECONFIG"
        exit 1
    fi
    
    log_success "Host connectivity verified"
}

create_tailscale_authkey() {
    log_info "Creating new Tailscale ephemeral reusable auth key..."
    
    local result
    result=$(ssh "$MERCURY_HOST" "headscale preauthkeys create --user $HEADSCALE_USER --ephemeral --reusable --tags 'tag:github-actions' 2>/dev/null" 2>&1) || {
        log_error "Failed to create Tailscale auth key: $result"
        exit 1
    }
    
    # The key is the last line that looks like a hex string (after any log output)
    local auth_key
    auth_key=$(echo "$result" | grep -E '^[a-f0-9]{48}$' | tail -n1)
    
    if [[ -z "$auth_key" ]]; then
        # Fallback: try to extract tskey format if it exists
        auth_key=$(echo "$result" | grep -o 'tskey-auth-[A-Za-z0-9_-]*' | head -n1)
    fi
    
    if [[ -z "$auth_key" ]]; then
        log_error "Could not extract auth key from result: $result"
        exit 1
    fi
    
    log_success "Created Tailscale auth key"
    echo "$auth_key"
}

setup_kubernetes_namespace() {
    local repo="$1"
    local environment="$2"
    local namespace="$3"
    
    log_info "Setting up Kubernetes namespace: $namespace"
    
    # Create namespace
    kubectl --kubeconfig="$KUBECONFIG" create namespace "$namespace" || true
    
    # Convert repo to valid label value (replace / with .)
    local repo_label=$(echo "$repo" | tr '/' '.')
    
    # Add labels to namespace
    kubectl --kubeconfig="$KUBECONFIG" label namespace "$namespace" "github.com/repository=$repo_label" "github.com/environment=$environment" "managed-by=github-actions" --overwrite || {
        log_error "Failed to label namespace"
        exit 1
    }
    
    # Create service account
    kubectl --kubeconfig="$KUBECONFIG" create serviceaccount github-actions -n "$namespace" || true
    
    # Label the service account
    kubectl --kubeconfig="$KUBECONFIG" label serviceaccount github-actions "github.com/repository=$repo_label" "github.com/environment=$environment" "managed-by=github-actions" -n "$namespace" --overwrite || {
        log_error "Failed to label service account"
        exit 1
    }
    
    # Note: Kubernetes RBAC doesn't support label-based namespace selection
    # The service account will only have admin access within its own namespace
    # Cross-namespace access would require a more complex solution or admission controller
    
    # Create RoleBinding for namespace admin access only
    kubectl --kubeconfig="$KUBECONFIG" create rolebinding github-actions-admin \
        --clusterrole=admin \
        --serviceaccount="$namespace:github-actions" \
        -n "$namespace" || true
    
    # Label the RoleBinding
    kubectl --kubeconfig="$KUBECONFIG" label rolebinding github-actions-admin "github.com/repository=$repo_label" "github.com/environment=$environment" "managed-by=github-actions" -n "$namespace" --overwrite || {
        log_error "Failed to label RoleBinding"
        exit 1
    }
    
    # Copy ghcr-regcred secret from kube-system to this namespace
    log_info "Copying ghcr-regcred secret from kube-system..."
    kubectl --kubeconfig="$KUBECONFIG" get secret ghcr-regcred -n kube-system -o yaml | \
        sed "s/namespace: kube-system/namespace: $namespace/" | \
        kubectl --kubeconfig="$KUBECONFIG" apply -f - || {
        log_error "Failed to copy ghcr-regcred secret"
        exit 1
    }
    
    log_success "Kubernetes namespace and RBAC configured"
}

create_service_account_kubeconfig() {
    local namespace="$1"
    local repo="$2"
    local environment="$3"
    
    # Convert repo to valid label value (replace / with .)
    local repo_label=$(echo "$repo" | tr '/' '.')
    
    log_info "Generating kubeconfig for service account..."
    
    # Delete existing secret if it exists (to handle type immutability)
    kubectl --kubeconfig="$KUBECONFIG" delete secret github-actions-token -n "$namespace" --ignore-not-found=true
    
    # Create service account token secret using kubectl
    kubectl --kubeconfig="$KUBECONFIG" apply -f - <<EOF
apiVersion: v1
type: kubernetes.io/service-account-token
kind: Secret
metadata:
  name: github-actions-token
  namespace: $namespace
  labels:
    github.com/repository: $repo_label
    github.com/environment: $environment
    managed-by: github-actions
  annotations:
    kubernetes.io/service-account.name: github-actions
EOF
    
    # Wait for token to be generated
    sleep 5
    
    # Verify the secret exists and has data
    log_info "Verifying service account token secret..."
    local secret_check
    secret_check=$(kubectl --kubeconfig="$KUBECONFIG" get secret github-actions-token -n "$namespace" -o name 2>/dev/null || echo "")
    
    if [[ -z "$secret_check" ]]; then
        log_error "Service account token secret not found. Waiting longer..."
        sleep 10
    fi
    
    # Get token using the method from the example script
    local token
    token=$(kubectl --kubeconfig="$KUBECONFIG" --namespace "$namespace" describe secret github-actions-token | grep 'token:' | awk '{print $2}')
    
    if [[ -z "$token" ]]; then
        log_error "Failed to retrieve service account token"
        log_info "Debug: Checking secret contents..."
        kubectl --kubeconfig="$KUBECONFIG" describe secret github-actions-token -n "$namespace" >&2
        exit 1
    fi
    
    # Get CA certificate using the method from the example script
    local ca_cert
    ca_cert=$(kubectl --kubeconfig="$KUBECONFIG" --namespace "$namespace" get secret github-actions-token -o "jsonpath={.data['ca\.crt']}")
    
    if [[ -z "$ca_cert" ]]; then
        log_error "Failed to retrieve CA certificate"
        exit 1
    fi
    
    # Get the actual cluster server and name from kubeconfig
    local cluster_server
    cluster_server=$(kubectl --kubeconfig="$KUBECONFIG" config view --minify -o jsonpath='{.clusters[0].cluster.server}')
    
    local cluster_name
    cluster_name=$(kubectl --kubeconfig="$KUBECONFIG" config view --minify -o jsonpath='{.clusters[0].name}')
    
    # Generate kubeconfig with proper cluster info
    local kubeconfig
    kubeconfig=$(cat <<EOF
apiVersion: v1
kind: Config
clusters:
- cluster:
    certificate-authority-data: ${ca_cert}
    server: ${cluster_server}
  name: ${cluster_name}
contexts:
- context:
    cluster: ${cluster_name}
    namespace: ${namespace}
    user: github-actions
  name: ${namespace}
current-context: ${namespace}
users:
- name: github-actions
  user:
    token: ${token}
EOF
)
    
    # Debug: Save raw kubeconfig to /tmp for inspection
    echo "$kubeconfig" > "/tmp/kubeconfig-${namespace}.yaml"
    log_info "Debug: Raw kubeconfig saved to /tmp/kubeconfig-${namespace}.yaml"
    
    # Debug: Show file info and first few lines
    log_info "Debug: Raw kubeconfig size: $(wc -c < "/tmp/kubeconfig-${namespace}.yaml") bytes"
    log_info "Debug: First 3 lines of raw kubeconfig:"
    head -n 3 "/tmp/kubeconfig-${namespace}.yaml" >&2
    
    # Debug: Show the complete kubeconfig that will be sent to GitHub
    log_info "Debug: Complete kubeconfig YAML:"
    cat "/tmp/kubeconfig-${namespace}.yaml" >&2
    
    # Validate the kubeconfig works locally
    log_info "Validating kubeconfig functionality..."
    if kubectl --kubeconfig="/tmp/kubeconfig-${namespace}.yaml" auth can-i get pods -n "${namespace}" >/dev/null 2>&1; then
        log_success "Kubeconfig validation: Service account can access namespace"
    else
        log_warning "Kubeconfig validation failed - testing basic connectivity"
        if kubectl --kubeconfig="/tmp/kubeconfig-${namespace}.yaml" cluster-info >/dev/null 2>&1; then
            log_info "Kubeconfig can connect to cluster but may lack permissions"
        else
            log_error "Kubeconfig appears invalid or cannot connect"
            log_info "Debug: Checking token and cert values..."
            echo "Token length: ${#token}" >&2
            echo "CA cert length: ${#ca_cert}" >&2
            echo "Cluster server: $cluster_server" >&2
            echo "Cluster name: $cluster_name" >&2
            exit 1
        fi
    fi
    
    log_success "Generated service account kubeconfig"
    echo "$kubeconfig"
}

set_github_secrets() {
    local repo="$1"
    local auth_key="$2"
    local namespace="$3"
    
    log_info "Setting GitHub repository secrets..."
    
    # Set TAILSCALE_AUTHKEY secret using here-string
    if gh secret set TAILSCALE_AUTHKEY --repo "$repo" <<< "$auth_key" >/dev/null 2>&1; then
        log_success "Set TAILSCALE_AUTHKEY secret in $repo"
    else
        log_error "Failed to set TAILSCALE_AUTHKEY secret in $repo"
        exit 1
    fi
    
    # Set KUBECONFIG secret from file
    if gh secret set KUBECONFIG --repo "$repo" < "/tmp/kubeconfig-${namespace}.yaml" >/dev/null 2>&1; then
        log_success "Set KUBECONFIG secret in $repo"
    else
        log_error "Failed to set KUBECONFIG secret in $repo"
        exit 1
    fi
    
    log_success "All secrets set successfully in GitHub repository"
}

generate_secrets() {
    local repo="$1"
    local environment="$2"
    local namespace="$3"
    
    log_info "Generating GitHub Actions secrets for: $repo"
    log_info "Environment: $environment"
    log_info "Namespace: $namespace"
    echo >&2
    
    check_dependencies
    check_github_auth
    test_connectivity
    echo >&2
    
    # Generate Tailscale auth key
    local new_auth_key
    new_auth_key=$(create_tailscale_authkey)
    
    # Setup Kubernetes namespace and RBAC
    setup_kubernetes_namespace "$repo" "$environment" "$namespace"
    
    # Generate service account kubeconfig
    local new_kubeconfig
    new_kubeconfig=$(create_service_account_kubeconfig "$namespace" "$repo" "$environment")
    
    # Automatically set secrets in GitHub repository
    set_github_secrets "$repo" "$new_auth_key" "$namespace"
    
    # Display the setup information
    echo
    echo "✅ GitHub Actions Setup Complete!"
    echo "================================="
    echo
    echo "Repository: $repo"
    echo "Environment: $environment"
    echo "Namespace: $namespace"
    echo
    echo "🔐 Secrets automatically set in GitHub:"
    echo "   • TAILSCALE_AUTHKEY"
    echo "   • KUBECONFIG"
    echo
    echo "📝 Usage in GitHub Actions workflow:"
    echo "   # Setup kubeconfig from secret"
    echo "   - name: Setup kubeconfig"
    echo "     run: |"
    echo "       mkdir -p ~/.kube"
    echo "       echo \"\${{ secrets.KUBECONFIG }}\" > ~/.kube/config"
    echo "       export KUBECONFIG=~/.kube/config"
    echo
    echo "   # Use Tailscale connection"
    echo "   - name: Connect to Tailscale"
    echo "     uses: ./.github/actions/setup-tailscale"
    echo "     with:"
    echo "       authkey: \${{ secrets.TAILSCALE_AUTHKEY }}"
    echo
    echo "🔐 Permissions:"
    echo "   • Full admin access within namespace: $namespace"
    echo "   • No access to other namespaces (isolated by design)"
    echo
}

main() {
    if [[ $# -eq 0 ]] || [[ "$1" == "--help" ]] || [[ "$1" == "-h" ]]; then
        show_help
        exit 0
    fi
    
    REPO="$1"
    ENVIRONMENT="${2:-prod}"
    
    # Validate repo format (alphanumeric, dash, underscore only)
    if [[ ! "$REPO" =~ ^[a-zA-Z0-9_-]+/[a-zA-Z0-9_-]+$ ]]; then
        log_error "Invalid repository format. Expected: owner/repo (alphanumeric, dash, underscore only)"
        show_help
        exit 1
    fi
    
    # Validate environment (alphanumeric, dash only, max 20 chars)
    if [[ ! "$ENVIRONMENT" =~ ^[a-z0-9-]{1,20}$ ]]; then
        log_error "Invalid environment. Must be lowercase alphanumeric with dashes, max 20 characters"
        exit 1
    fi
    
    # Convert owner/repo to namespace name (replace / with -)
    # Ensure namespace follows Kubernetes naming rules
    NAMESPACE=$(echo "$REPO-$ENVIRONMENT" | tr '/' '-' | tr '[:upper:]' '[:lower:]' | sed 's/[^a-z0-9-]/-/g')
    
    # Validate final namespace name
    if [[ ! "$NAMESPACE" =~ ^[a-z0-9]([-a-z0-9]*[a-z0-9])?$ ]] || [[ ${#NAMESPACE} -gt 63 ]]; then
        log_error "Generated namespace name invalid or too long: $NAMESPACE"
        exit 1
    fi
    
    generate_secrets "$REPO" "$ENVIRONMENT" "$NAMESPACE"
}

main "$@"